<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ani Pro - Professional Animation System</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            color: white;
        }
        #canvas-container { width: 100vw; height: 100vh; position: relative; }
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 20px 40px;
            border-radius: 50px;
            display: flex;
            gap: 15px;
            align-items: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        button:hover { transform: translateY(-2px); }
        button.recording { background: linear-gradient(135deg, #f44336, #e91e63); animation: pulse-red 1.5s infinite; }
        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.7); }
            50% { box-shadow: 0 0 20px 10px rgba(244, 67, 54, 0); }
        }
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 15px;
            font-size: 14px;
            backdrop-filter: blur(10px);
        }
        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-connected { background: #4CAF50; }
        .status-disconnected { background: #f44336; }
        .status-thinking { background: #FFC107; }
        #emotion-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        #transcript {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 20px;
            max-width: 80%;
            text-align: center;
            display: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 24px;
            font-weight: 600;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="loading"><div class="spinner"></div>Loading Ani Pro...</div>
    <div id="status" style="display: none;">
        <span class="status-dot status-disconnected"></span>
        <span id="status-text">Disconnected</span>
    </div>
    <div id="emotion-display" style="display: none;">
        <div style="opacity: 0.7; font-size: 12px; margin-bottom: 5px;">Animation</div>
        <div id="emotion-text">Idle</div>
    </div>
    <div id="transcript"></div>
    <div id="controls" style="display: none;">
        <button id="talk-btn">Hold to Talk</button>
        <span id="mic-status" style="font-size: 12px; opacity: 0.7;">Click and speak</span>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.1.2/lib/three-vrm.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // State
        let scene, camera, renderer, controls;
        let currentVRM = null;
        let mixer = null;  // AnimationMixer for professional animations
        let idleAction = null;
        let ws = null;
        let recognition = null;
        let isListening = false;
        let currentAudio = null;
        const clock = new THREE.Clock();

        const EMOTION_MAP = {
            'joy': 'happy',
            'sad': 'sad',
            'anger': 'angry',
            'surprise': 'surprised',
            'neutral': 'neutral'
        };

        // Initialize scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x212121);

            camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.4, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const rimLight = new THREE.DirectionalLight(0x667eea, 0.5);
            rimLight.position.set(-1, 1, -1);
            scene.add(rimLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1.2, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.update();

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Load VRM with professional animation setup
        async function loadVRM() {
            const loader = new GLTFLoader();
            loader.register((parser) => new VRMLoaderPlugin(parser));

            try {
                const gltf = await loader.loadAsync('/character/darkhair.vrm');
                const vrm = gltf.userData.vrm;

                if (currentVRM) {
                    scene.remove(currentVRM.scene);
                    VRMUtils.deepDispose(currentVRM.scene);
                }

                currentVRM = vrm;
                scene.add(vrm.scene);
                vrm.scene.rotation.y = Math.PI;

                // Create AnimationMixer for professional animations
                mixer = new THREE.AnimationMixer(vrm.scene);

                // Create procedural idle animation
                createProceduralIdleAnimation();

                console.log('[OK] VRM loaded with professional animation system');

                document.getElementById('loading').style.display = 'none';
                document.getElementById('controls').style.display = 'flex';
                document.getElementById('status').style.display = 'block';
                document.getElementById('emotion-display').style.display = 'block';

            } catch (error) {
                console.error('[ERROR] Failed to load VRM:', error);
                document.getElementById('loading').innerHTML =
                    '<div style="color: #f44336;">Failed to load character</div>';
            }
        }

        // Create professional procedural idle animation
        function createProceduralIdleAnimation() {
            if (!currentVRM || !currentVRM.humanoid) return;

            const tracks = [];
            const duration = 4.0; // 4 second loop
            const times = [];
            const fps = 30;
            const numFrames = duration * fps;

            // Generate keyframes
            for (let i = 0; i <= numFrames; i++) {
                times.push(i / fps);
            }

            // Breathing animation (chest/spine)
            const chestBone = currentVRM.humanoid.getNormalizedBoneNode('chest');
            if (chestBone) {
                const chestQuats = [];
                for (let i = 0; i <= numFrames; i++) {
                    const t = i / fps;
                    const breathCycle = Math.sin(t * Math.PI) * 0.02;  // One breath per 4s
                    const quat = new THREE.Quaternion();
                    quat.setFromEuler(new THREE.Euler(breathCycle, 0, 0));
                    chestQuats.push(quat.x, quat.y, quat.z, quat.w);
                }
                tracks.push(new THREE.QuaternionKeyframeTrack(
                    `${chestBone.name}.quaternion`,
                    times,
                    chestQuats
                ));
            }

            // Head natural movement
            const headBone = currentVRM.humanoid.getNormalizedBoneNode('head');
            if (headBone) {
                const headQuats = [];
                for (let i = 0; i <= numFrames; i++) {
                    const t = i / fps;
                    const sway = Math.sin(t * Math.PI * 0.5) * 0.05;
                    const nod = Math.sin(t * Math.PI * 0.3) * 0.03;
                    const tilt = Math.sin(t * Math.PI * 0.4) * 0.02;
                    const quat = new THREE.Quaternion();
                    quat.setFromEuler(new THREE.Euler(nod, sway, tilt));
                    headQuats.push(quat.x, quat.y, quat.z, quat.w);
                }
                tracks.push(new THREE.QuaternionKeyframeTrack(
                    `${headBone.name}.quaternion`,
                    times,
                    headQuats
                ));
            }

            // Hip subtle sway
            const hipsBone = currentVRM.humanoid.getNormalizedBoneNode('hips');
            if (hipsBone) {
                const hipsPositions = [];
                for (let i = 0; i <= numFrames; i++) {
                    const t = i / fps;
                    const sway = Math.sin(t * Math.PI * 0.5) * 0.01;
                    hipsPositions.push(sway, 0, 0);
                }
                tracks.push(new THREE.VectorKeyframeTrack(
                    `${hipsBone.name}.position`,
                    times,
                    hipsPositions
                ));
            }

            // Create animation clip
            const clip = new THREE.AnimationClip('idle', duration, tracks);
            idleAction = mixer.clipAction(clip);
            idleAction.loop = THREE.LoopRepeat;
            idleAction.play();

            console.log('[OK] Procedural idle animation created');
        }

        // Expression system
        function setExpression(emotion, intensity = 1.0) {
            if (!currentVRM || !currentVRM.expressionManager) return;

            const expressionName = EMOTION_MAP[emotion] || 'neutral';

            try {
                currentVRM.expressionManager.setValue('happy', 0);
                currentVRM.expressionManager.setValue('sad', 0);
                currentVRM.expressionManager.setValue('angry', 0);
                currentVRM.expressionManager.setValue('surprised', 0);
                currentVRM.expressionManager.setValue('neutral', 0);
                currentVRM.expressionManager.setValue(expressionName, intensity);

                document.getElementById('emotion-text').textContent =
                    emotion.charAt(0).toUpperCase() + emotion.slice(1);

            } catch (error) {
                console.error('[ERROR] Expression:', error);
            }
        }

        // Lip-sync
        function setViseme(viseme, weight = 1.0) {
            if (!currentVRM || !currentVRM.expressionManager) return;

            const visemeMap = { 'A': 'aa', 'E': 'ee', 'I': 'ih', 'O': 'oh', 'U': 'ou' };
            const vrmViseme = visemeMap[viseme] || 'aa';

            try {
                Object.values(visemeMap).forEach(v => {
                    currentVRM.expressionManager.setValue(v, 0);
                });
                currentVRM.expressionManager.setValue(vrmViseme, weight);
            } catch (error) {
                // Silently handle
            }
        }

        // WebSocket
        function connectWebSocket() {
            if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;

            ws = new WebSocket('ws://localhost:8000/ws');

            ws.onopen = () => {
                console.log('[OK] WebSocket connected');
                updateStatus('connected', 'Ready');
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);

                if (data.type === 'emotion') {
                    setExpression(data.emotion, data.intensity || 1.0);
                }
                if (data.type === 'audio') {
                    playAudio(data.audio);
                }
                if (data.status === 'success' && data.data) {
                    showTranscript(data.data.utterance, false);
                }
            };

            ws.onerror = (error) => {
                console.error('[ERROR] WebSocket:', error);
                updateStatus('disconnected', 'Error');
            };

            ws.onclose = () => {
                updateStatus('disconnected', 'Disconnected');
                ws = null;
                setTimeout(connectWebSocket, 3000);
            };
        }

        function updateStatus(status, text) {
            const statusDot = document.querySelector('.status-dot');
            const statusText = document.getElementById('status-text');

            statusDot.className = 'status-dot';
            if (status === 'connected') statusDot.classList.add('status-connected');
            else if (status === 'thinking') statusDot.classList.add('status-thinking');
            else statusDot.classList.add('status-disconnected');

            statusText.textContent = text;
        }

        function showTranscript(text, isUser = false) {
            const transcript = document.getElementById('transcript');
            transcript.textContent = (isUser ? 'You: ' : 'Ani: ') + text;
            transcript.style.display = 'block';
            setTimeout(() => { transcript.style.display = 'none'; }, 5000);
        }

        // Audio playback with lip-sync
        async function playAudio(audioBase64) {
            if (currentAudio) currentAudio.pause();

            try {
                const audioData = atob(audioBase64);
                const arrayBuffer = new ArrayBuffer(audioData.length);
                const view = new Uint8Array(arrayBuffer);
                for (let i = 0; i < audioData.length; i++) {
                    view[i] = audioData.charCodeAt(i);
                }

                const blob = new Blob([arrayBuffer], { type: 'audio/wav' });
                const audioUrl = URL.createObjectURL(blob);
                currentAudio = new Audio(audioUrl);

                currentAudio.addEventListener('play', () => { animateMouth(); });
                currentAudio.addEventListener('ended', () => {
                    stopMouth();
                    updateStatus('connected', 'Ready');
                });

                await currentAudio.play();
            } catch (error) {
                console.error('[ERROR] Audio:', error);
            }
        }

        let mouthAnimationFrame = null;
        function animateMouth() {
            const visemes = ['A', 'I', 'U', 'E', 'O'];
            let index = 0;
            function animate() {
                setViseme(visemes[index], 0.7);
                index = (index + 1) % visemes.length;
                mouthAnimationFrame = setTimeout(animate, 100);
            }
            animate();
        }

        function stopMouth() {
            if (mouthAnimationFrame) {
                clearTimeout(mouthAnimationFrame);
                mouthAnimationFrame = null;
            }
            setViseme('A', 0);
        }

        // Speech recognition
        function initSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                document.getElementById('mic-status').textContent = 'Not supported';
                return;
            }

            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'zh-CN';

            recognition.onstart = () => {
                isListening = true;
                document.getElementById('talk-btn').classList.add('recording');
                document.getElementById('mic-status').textContent = 'Listening...';
                updateStatus('thinking', 'Listening...');
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                showTranscript(transcript, true);
                sendTextToAI(transcript);
            };

            recognition.onerror = (event) => {
                console.error('[ERROR] Speech:', event.error);
                updateStatus('connected', 'Ready');
                isListening = false;
                document.getElementById('talk-btn').classList.remove('recording');
            };

            recognition.onend = () => {
                isListening = false;
                document.getElementById('talk-btn').classList.remove('recording');
                document.getElementById('mic-status').textContent = 'Click and speak';
            };
        }

        function sendTextToAI(text) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                console.error('[ERROR] WebSocket not connected');
                updateStatus('disconnected', 'Not connected');
                return;
            }

            updateStatus('thinking', 'Thinking...');
            ws.send(JSON.stringify({ type: 'user_input', text: text }));
        }

        // Button events
        document.getElementById('talk-btn').addEventListener('mousedown', () => {
            if (recognition && !isListening) {
                try { recognition.start(); } catch (error) { console.error(error); }
            }
        });

        document.getElementById('talk-btn').addEventListener('mouseup', () => {
            if (recognition && isListening) recognition.stop();
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (currentVRM) {
                currentVRM.update(delta);
            }

            if (mixer) {
                mixer.update(delta);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize
        window.addEventListener('load', async () => {
            initScene();
            await loadVRM();
            initSpeechRecognition();
            connectWebSocket();
            animate();
        });

        // Debug
        window.ani = {
            setExpression,
            sendText: sendTextToAI,
            vrm: () => currentVRM,
            mixer: () => mixer
        };
    </script>
</body>
</html>
